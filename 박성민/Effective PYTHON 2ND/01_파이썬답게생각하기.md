# Chapter 1 - 파이썬답게 생각하기
## 사용 중인 파이썬의 버전을 알아두기
파이썬 버전 확인하기
```console
$ python --version
python 3.8.15
```
파이썬의 내장 모듈 sys의 값을 검사하면 현재 실행 중인 파이썬 버전을 알 수 있다.
```python
import sys
print(sys.version_info)
print(sys.version)
```
2020년 1월 부터 파이썬2의 공식적으로 지원이 종료되었기 때문에 파이썬3를 쓰는 것을 권장한다.

---
## PEP 8 스타일 가이드
`Python Enhancement Proposal #8`(PEP 8)은 파이썬 코드를 어떤 형식으로 작성할지 알려주는 스타일 가이드다. [온라인가이드](https://www.python.org/dev/peps/pep-0008/)

### 공백
* 탭 대신 스페이스 사용
* 문법적으로 중요한 들여쓰기엔 4칸 스페이스 사용
* 라인 길이는 79개 문자 이하
* 긴 식을 다음 줄에 쓸 경우 4 스페이스 더 들여쓰기
* 파일 안 함수와 클래스 사이 빈 줄 두 줄 넣기
* 클래스 안 메서드 사이엔 빈 줄 한줄 넣기
* 딕셔너리에서 키와 콜론( : ) 사이엔 공백 없이, 콜론( : )과 값 사이엔 공백 한 칸 넣기
* 변수 대입에서 = 전후엔 공백 한 칸씩
* 타입 표기 시, 변수 이름과 콜론 사이 공백 넣지 않고, 콜론과 타입 정보 사이 공백 한 칸

### 명명 규약
* 함수, 변수, attribute는 **lowercase_underscore**
* protected instance attribute는 **_leading_underscore**
* private instance attribute는 **__leading_underscore**
* 클래스(예외 포함)는 **CapitalizedWord**
* 모듈 수준의 상수는 **ALL_CAPS**
* 클래스 instance 메서드는 호출 대상 객체를 가리키는 첫 번째 인자의 이름을 **self**로 한다.
* 클래스 메서드는 클래스를 가리키는 첫 번째 인자의 이름을 **cls**로 한다.

### 식과 문장
* 긍정적인 식을 부정하지 말고(**if not a is b**) 부정을 내부에 넣기(**if a is not b**)
* 빈 컨테이너(container)나 시퀀스(sequence)([], ' ')의 길이를 0과 비교하지말고(if len(something) == 0), **if not 컨테이너** 조건문 쓰기
* 비어 있지 않은 컨테이너나 시퀀스를 검사할 때 0보다 큰지 비교하지말고, **if 컨테이너** 조건문 쓰기
* 한 줄짜리 **if**, **for**, **while**, **execept** 복합문을 사용하지 않기
* 식을 한 줄에 다 쓸 수 없는 경우, 괄호로 둘러싼 뒤 줄바꿈과 들여쓰기로 읽기 쉽게 만들기
* 여러 줄에 걸쳐 식을 쓸 땐 줄이 계속된다는 표시를 하는 \ 문자보단 괄호를 이용하기

### 임포트
* import 문(from x import y)을 항상 파일 맨 앞에 작성
* 모듈 임포트 시 상대적인 이름 보단 절대적인 이름 쓰기
  * bar 패키지 foo 임포트 > **from bar import foo**
* 반드시 상대적인 경로로 임포트해야 하는 경우 **from . import foo**와 같이 명시적인 구문 사용
* 임포트는 표준 라이브러리 모듈, 서드 파티 모듈, 사용자 정의 모듈 순으로, 섹션 내에선 알파벳 순으로 적기

---
## bytes와 str의 차이
파이썬에는 문자열 데이터의 신퀀스를 표현하기위해 `bytes`와 `str` 두 타입을 사용한다. `bytes`는 unsigned 8bit 값을 갖는다.
```python
a = b'h\x65llo'
print(list(a))
print(a)
```
```console
[104, 101, 108, 108, 111]
b'hello'
```
`str`은 유니코드 `코드 포인트`가 들어 있다.
```python
a = 'a\u0300 propos'
print(list(a))
print(a)
```
```console
['a', '̀ ', ' ', 'p', 'r', 'o', 'p', 'o', 's']
à propos
```
str 인스턴스에는 직접 대응하는 이진 인코딩이 없고 bytes에는 직접 대응하는 텍스트 인코디이 없다. 유니코드 데이터를 이진 데이터로 변환하려면 str의 `encode` 메서드를 호출해야하고, 이진 데이터를 유니코드 데이터로 변환하려면 bytes의 `decode` 메서드를 호출해야 한다. 두 메서드를 호출할 땐 인코딩 방식을 명시적으로 지정할 수 있고, 일반적인 시스템 기본값인 UTF-8을 쓸 수 있다.

`유니코드 샌드위치`는 유니코드 데이터를 인코딩하거나 디코딩하는 부분을 인터페이스의 가장  먼 경계 지점에 위치시키는 방식이다. 프로그램의 핵심 부분에선 str을 사용해야하고 문자 인코딩에 대해선 가정하지 않아야 한다. 이러한 방식이면 여러 방식의 텍스트 인코딩으로 입력 데이터를 받을 수 있고 출력 텍스트 인코딩은 한가지로 제한할 수 있다.

파이썬에선 문자를 표현하는 타입이 두 개이므로, 다음과 같은 상황이 발생한다.
* 인코딩된 8비트 시퀀스를 사용하고 싶다.
* 특정 인코딩을 지정하지 않은 유니콛 문자열을 사용하고 싶다.
* 
위 두 경우를 위해 bytes나 str을 항상 str로 반환하거나, 항상 bytes로 반환하는 함수가 필요하다.

```python
# bytes나 str을 항상 str로 반환
def to_str(bytes_or_str):
    if isinstance(bytes_or_str, bytes):
        value = bytes_or_str.decode('utf-8')
    else:
        value = bytes_orstr
    return value

# bytes나 str을 항상 bytes로 반환
def to_bytes(bytes_or_str):
    if isinstance(bytes_or_str, str):
        value = bytes_or_str.encode('utf-8')
    else:
        value = bytes_orstr
    return value
```
bytes와 str을 사용할 땐 두 가지 문제점이 있다.
1. bytes와 str은 똑같이 작동하는 것처럼 보이지만 각각은 서로 호환되지 않는다.
    `+`연산자를 사용하면 bytes끼리 더하거나 str끼리 더할 수 있지만 str에 bytes를 더할 순 없다. `이항` 연산자도 마찬가지이다. 또한 내부에 같은 문자들이 들어 있더라도 같은지 비교를 하면 항상 False가 나온다. `%` 연산자는 각 타입의 형식화 문자열(format string)에 대해 작동한다.
    ```python
    # OK
    print(b'one' + b'two')
    print('one' + 'two')
    assert b'red' > b'blue'
    assert 'red' > 'blue'
    print(b'red %s' % b'blue')
    print('red %s' % 'blue')

    # Error
    print(b'one' + 'two')
    assert 'red' > b'blue'
    print(b'red %s' % 'blue')

    print(b'foo' == 'foo') # False
    ```
2. 파일 관련 핸들과 관련한 연산자들은 기본으로 유니코드 문자열을 요구한다.
   파일을 bytes로 읽거나 쓰기위해선 `open` 호출 시, ('w')대신 ('wb')로 ('r') 대신 ('rb')로 써야 한다. 또한 다른 방식으로 인코딩된 파일을 읽을 땐 명시적으로 인코딩 방식을 써 줄 수 있다.

---