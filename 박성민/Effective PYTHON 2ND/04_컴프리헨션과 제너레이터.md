# Chapter 4 - 컴프리헨션과 제너레이터

## map과 filter 대신 컴프리헨션 사용
파이썬에선 다른 시퀀스나 이터러블에서 새 리스트를 만들어내는 간결한 구문인 `리스트 컴프리헨션`을 제공한다.

```py
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
squares = [x**2 for x in a]
```
컴프리헨션에서는 원소를 필터링하는 것도 간편하다.

```py
even_squares = [x**2 for x in a if x % 2 == 0]
```
또한, 딕셔너리와 집합에 관한 컴프리헨션도 있다. 각각 `딕셔너리 컴프리헨션`과 `집합 컴프리헨션`이라고 한다.

```py
even_squares_dict = {x: x**2 for x in a if x % 2 == 0}
threes_cubed_set = {x**3 for x in a if x % 3 == 0}
```

내장함수 map과 filter를 사용하여 위와 같은 역할을 하게 하려면 시각적잡음이 생긴다.
```py
alt = map(lambda x: x**2, filter(lambda x: x % 2 == 0, a))
alt_dict = dict(map(lambda x: (x, x**2), filter(lambda x: x % 2 == 0, a)))
alt_set = set(map(lambda x: x**3, filter(lambda x: x % 3 == 0, a)))
```

## 컴프리헨션 내부 제어 하위 식을 세 개이상 사용 금지
컴프리헨션은 루프를 여러 수준으로 내포하도록 할 수 있다.
```py
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flat = [x for row in matrix for x in row]
print(flat)
```
```
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```
이 때 하위식은 왼쪽에서 오른쪽으로 실행된다.

또는, 2차원 배열을 복사해야 할 땐 다음과 같이 할 수 있다.
```py
squared = [[x**2 for x in row] for row in matrix]
print(squared)
```
```
[[1, 4, 9], [16, 25, 36], [49, 64, 81]]
```
이 땐 시각적 잡음이 약간 있지만 괜찮다.

하지만 다음과 같이 3개이상의 루프문이 들어가 있으면 일반 루프문이 더 명확할 수 있다.
```py
# 컴프리헨션
my_lists = [
    [[1, 2, 3], [4, 5, 6]],
    ...
]
flat = [x for sublist1 in my_lists
        for sublist2 in sublist1
        for x in sublist2]

# 일반 루프문
flat = []
for sublist1 in my_lists:
    for sublist2 in sublist1:
        flat.extend(sublist2)
```

컴프리헨션은 if문도 여럿 쓸 수 있다. 여러 조건을 같은 수준의 루프에 사용하면 암시적으로 and 식을 의미한다.
```py
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
b = [x for x in a if x > 4 if x % 2 == 0]
b = [x for x in a if x > 4 and x % 2 == 0]
```

또한, 각 수준의 for 하위 식 다음에 if를 추가함으로써 각 수준마다 조건을 지정할 수 있다. 하지만 이를 사용하면 다음 코드처럼 길진 않지만, 읽기 어려운 코드가 만들어진다.
```py
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
filtered = [[x for x in row if x % 3 == 0]
            for row in matrix if sum(row) >= 10]
```

위 코드와 같이 컴프리헨션 내부 하위 식이 3개 이상이면 처음 코드를 보는 사람이 이해하기 어려워진다. 따라서 컴프리헨션 내부 하위 식은 (조건문 두 개, 루프 두 개, 조건문 한 개와 루프문 한 개)와 같이 사용하는 것이 좋다.